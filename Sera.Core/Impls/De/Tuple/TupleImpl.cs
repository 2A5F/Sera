// <auto-generated>

#nullable enable

using System;
using System.Runtime.CompilerServices;
using Sera.Core.Impls.De;
using Sera.Utils;

namespace Sera.Core.Impls.De;

#region Empty

public readonly struct TupleImpl : ISeraColion<ValueTuple>, ITupleSeraColion<ValueTuple>
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R Collect<R, C>(ref C colctor, InType<ValueTuple>? t = null) where C : ISeraColctor<ValueTuple, R>
        => colctor.CTuple(this, new IdentityMapper<ValueTuple>(), new Type<ValueTuple>());

    public int? Size
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => 0;
    }

    public int? TotalSize
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => 0;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public ValueTuple Builder(Type<ValueTuple> b = default) => default;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R CollectItem<R, C>(ref C colctor, int index, Type<ValueTuple> b = default)
        where C : ITupleSeraColctor<ValueTuple, R>
        => colctor.CNone();
}

#endregion

#region Size1

public readonly struct TupleImpl<T1, D1>
    (D1 d1) :
    ISeraColion<ValueTuple<T1>>,
    ISeraColion<Tuple<T1>>,
    ITupleRestSeraColion<ValueTuple<T1>>,
    ITupleRestSeraColion<Tuple<T1>>,
    ITupleSeraColion<ValueTuple<T1>>
    where D1 : ISeraColion<T1>
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R Collect<R, C>(ref C colctor, InType<ValueTuple<T1>>? t) where C : ISeraColctor<ValueTuple<T1>, R>
        => colctor.CTuple(this, new IdentityMapper<ValueTuple<T1>>(), new Type<ValueTuple<T1>>());

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R Collect<R, C>(ref C colctor, InType<Tuple<T1>>? t) where C : ISeraColctor<Tuple<T1>, R>
        => colctor.CTuple(this, new ValueTupleToTupleMapper<T1>(), new Type<ValueTuple<T1>>());

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R CollectRest<R, C>(ref C colctor, InType<ValueTuple<T1>>? t = null) where C : ITupleRestSeraColctor<ValueTuple<T1>, R>
        => colctor.CTupleRest(this, new IdentityMapper<ValueTuple<T1>>(), new Type<ValueTuple<T1>>());

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R CollectRest<R, C>(ref C colctor, InType<Tuple<T1>>? t = null) where C : ITupleRestSeraColctor<Tuple<T1>, R>
        => colctor.CTupleRest(this, new ValueTupleToTupleMapper<T1>(), new Type<ValueTuple<T1>>());

    public int? Size
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => 1;
    }

    public int? TotalSize
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => 1;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public ValueTuple<T1> Builder(Type<ValueTuple<T1>> b) => default;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R CollectItem<R, C>(ref C colctor, int index, Type<ValueTuple<T1>> b)
        where C : ITupleSeraColctor<ValueTuple<T1>, R>
        => index switch
        {
            0 => colctor.CItem(d1, new ValueTupleEffector<T1>.Item1(), new Type<T1>()),
            _ => colctor.CNone(),
        };
}

public static class ValueTupleEffector<T1>
{
    public readonly struct Item1 : ISeraEffector<ValueTuple<T1>, T1>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Effect(ref ValueTuple<T1> target, T1 value)
            => target.Item1 = value;
    }
}

public readonly struct ValueTupleToTupleMapper<T1> : 
    ISeraMapper<ValueTuple<T1>, Tuple<T1>>
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Tuple<T1> Map(ValueTuple<T1> value, InType<Tuple<T1>>? u) 
        => new(value.Item1);
}

#endregion

#region Size2

public readonly struct TupleImpl<T1, T2, D1, D2>
    (D1 d1, D2 d2) :
    ISeraColion<ValueTuple<T1, T2>>,
    ISeraColion<Tuple<T1, T2>>,
    ITupleRestSeraColion<ValueTuple<T1, T2>>,
    ITupleRestSeraColion<Tuple<T1, T2>>,
    ITupleSeraColion<ValueTuple<T1, T2>>
    where D1 : ISeraColion<T1>
    where D2 : ISeraColion<T2>
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R Collect<R, C>(ref C colctor, InType<ValueTuple<T1, T2>>? t) where C : ISeraColctor<ValueTuple<T1, T2>, R>
        => colctor.CTuple(this, new IdentityMapper<ValueTuple<T1, T2>>(), new Type<ValueTuple<T1, T2>>());

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R Collect<R, C>(ref C colctor, InType<Tuple<T1, T2>>? t) where C : ISeraColctor<Tuple<T1, T2>, R>
        => colctor.CTuple(this, new ValueTupleToTupleMapper<T1, T2>(), new Type<ValueTuple<T1, T2>>());

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R CollectRest<R, C>(ref C colctor, InType<ValueTuple<T1, T2>>? t = null) where C : ITupleRestSeraColctor<ValueTuple<T1, T2>, R>
        => colctor.CTupleRest(this, new IdentityMapper<ValueTuple<T1, T2>>(), new Type<ValueTuple<T1, T2>>());

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R CollectRest<R, C>(ref C colctor, InType<Tuple<T1, T2>>? t = null) where C : ITupleRestSeraColctor<Tuple<T1, T2>, R>
        => colctor.CTupleRest(this, new ValueTupleToTupleMapper<T1, T2>(), new Type<ValueTuple<T1, T2>>());

    public int? Size
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => 2;
    }

    public int? TotalSize
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => 2;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public ValueTuple<T1, T2> Builder(Type<ValueTuple<T1, T2>> b) => default;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R CollectItem<R, C>(ref C colctor, int index, Type<ValueTuple<T1, T2>> b)
        where C : ITupleSeraColctor<ValueTuple<T1, T2>, R>
        => index switch
        {
            0 => colctor.CItem(d1, new ValueTupleEffector<T1, T2>.Item1(), new Type<T1>()),
            1 => colctor.CItem(d2, new ValueTupleEffector<T1, T2>.Item2(), new Type<T2>()),
            _ => colctor.CNone(),
        };
}

public static class ValueTupleEffector<T1, T2>
{
    public readonly struct Item1 : ISeraEffector<ValueTuple<T1, T2>, T1>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Effect(ref ValueTuple<T1, T2> target, T1 value)
            => target.Item1 = value;
    }
    public readonly struct Item2 : ISeraEffector<ValueTuple<T1, T2>, T2>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Effect(ref ValueTuple<T1, T2> target, T2 value)
            => target.Item2 = value;
    }
}

public readonly struct ValueTupleToTupleMapper<T1, T2> : 
    ISeraMapper<ValueTuple<T1, T2>, Tuple<T1, T2>>
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Tuple<T1, T2> Map(ValueTuple<T1, T2> value, InType<Tuple<T1, T2>>? u) 
        => new(value.Item1, value.Item2);
}

#endregion

#region Size3

public readonly struct TupleImpl<T1, T2, T3, D1, D2, D3>
    (D1 d1, D2 d2, D3 d3) :
    ISeraColion<ValueTuple<T1, T2, T3>>,
    ISeraColion<Tuple<T1, T2, T3>>,
    ITupleRestSeraColion<ValueTuple<T1, T2, T3>>,
    ITupleRestSeraColion<Tuple<T1, T2, T3>>,
    ITupleSeraColion<ValueTuple<T1, T2, T3>>
    where D1 : ISeraColion<T1>
    where D2 : ISeraColion<T2>
    where D3 : ISeraColion<T3>
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R Collect<R, C>(ref C colctor, InType<ValueTuple<T1, T2, T3>>? t) where C : ISeraColctor<ValueTuple<T1, T2, T3>, R>
        => colctor.CTuple(this, new IdentityMapper<ValueTuple<T1, T2, T3>>(), new Type<ValueTuple<T1, T2, T3>>());

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R Collect<R, C>(ref C colctor, InType<Tuple<T1, T2, T3>>? t) where C : ISeraColctor<Tuple<T1, T2, T3>, R>
        => colctor.CTuple(this, new ValueTupleToTupleMapper<T1, T2, T3>(), new Type<ValueTuple<T1, T2, T3>>());

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R CollectRest<R, C>(ref C colctor, InType<ValueTuple<T1, T2, T3>>? t = null) where C : ITupleRestSeraColctor<ValueTuple<T1, T2, T3>, R>
        => colctor.CTupleRest(this, new IdentityMapper<ValueTuple<T1, T2, T3>>(), new Type<ValueTuple<T1, T2, T3>>());

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R CollectRest<R, C>(ref C colctor, InType<Tuple<T1, T2, T3>>? t = null) where C : ITupleRestSeraColctor<Tuple<T1, T2, T3>, R>
        => colctor.CTupleRest(this, new ValueTupleToTupleMapper<T1, T2, T3>(), new Type<ValueTuple<T1, T2, T3>>());

    public int? Size
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => 3;
    }

    public int? TotalSize
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => 3;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public ValueTuple<T1, T2, T3> Builder(Type<ValueTuple<T1, T2, T3>> b) => default;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R CollectItem<R, C>(ref C colctor, int index, Type<ValueTuple<T1, T2, T3>> b)
        where C : ITupleSeraColctor<ValueTuple<T1, T2, T3>, R>
        => index switch
        {
            0 => colctor.CItem(d1, new ValueTupleEffector<T1, T2, T3>.Item1(), new Type<T1>()),
            1 => colctor.CItem(d2, new ValueTupleEffector<T1, T2, T3>.Item2(), new Type<T2>()),
            2 => colctor.CItem(d3, new ValueTupleEffector<T1, T2, T3>.Item3(), new Type<T3>()),
            _ => colctor.CNone(),
        };
}

public static class ValueTupleEffector<T1, T2, T3>
{
    public readonly struct Item1 : ISeraEffector<ValueTuple<T1, T2, T3>, T1>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Effect(ref ValueTuple<T1, T2, T3> target, T1 value)
            => target.Item1 = value;
    }
    public readonly struct Item2 : ISeraEffector<ValueTuple<T1, T2, T3>, T2>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Effect(ref ValueTuple<T1, T2, T3> target, T2 value)
            => target.Item2 = value;
    }
    public readonly struct Item3 : ISeraEffector<ValueTuple<T1, T2, T3>, T3>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Effect(ref ValueTuple<T1, T2, T3> target, T3 value)
            => target.Item3 = value;
    }
}

public readonly struct ValueTupleToTupleMapper<T1, T2, T3> : 
    ISeraMapper<ValueTuple<T1, T2, T3>, Tuple<T1, T2, T3>>
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Tuple<T1, T2, T3> Map(ValueTuple<T1, T2, T3> value, InType<Tuple<T1, T2, T3>>? u) 
        => new(value.Item1, value.Item2, value.Item3);
}

#endregion

#region Size4

public readonly struct TupleImpl<T1, T2, T3, T4, D1, D2, D3, D4>
    (D1 d1, D2 d2, D3 d3, D4 d4) :
    ISeraColion<ValueTuple<T1, T2, T3, T4>>,
    ISeraColion<Tuple<T1, T2, T3, T4>>,
    ITupleRestSeraColion<ValueTuple<T1, T2, T3, T4>>,
    ITupleRestSeraColion<Tuple<T1, T2, T3, T4>>,
    ITupleSeraColion<ValueTuple<T1, T2, T3, T4>>
    where D1 : ISeraColion<T1>
    where D2 : ISeraColion<T2>
    where D3 : ISeraColion<T3>
    where D4 : ISeraColion<T4>
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R Collect<R, C>(ref C colctor, InType<ValueTuple<T1, T2, T3, T4>>? t) where C : ISeraColctor<ValueTuple<T1, T2, T3, T4>, R>
        => colctor.CTuple(this, new IdentityMapper<ValueTuple<T1, T2, T3, T4>>(), new Type<ValueTuple<T1, T2, T3, T4>>());

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R Collect<R, C>(ref C colctor, InType<Tuple<T1, T2, T3, T4>>? t) where C : ISeraColctor<Tuple<T1, T2, T3, T4>, R>
        => colctor.CTuple(this, new ValueTupleToTupleMapper<T1, T2, T3, T4>(), new Type<ValueTuple<T1, T2, T3, T4>>());

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R CollectRest<R, C>(ref C colctor, InType<ValueTuple<T1, T2, T3, T4>>? t = null) where C : ITupleRestSeraColctor<ValueTuple<T1, T2, T3, T4>, R>
        => colctor.CTupleRest(this, new IdentityMapper<ValueTuple<T1, T2, T3, T4>>(), new Type<ValueTuple<T1, T2, T3, T4>>());

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R CollectRest<R, C>(ref C colctor, InType<Tuple<T1, T2, T3, T4>>? t = null) where C : ITupleRestSeraColctor<Tuple<T1, T2, T3, T4>, R>
        => colctor.CTupleRest(this, new ValueTupleToTupleMapper<T1, T2, T3, T4>(), new Type<ValueTuple<T1, T2, T3, T4>>());

    public int? Size
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => 4;
    }

    public int? TotalSize
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => 4;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public ValueTuple<T1, T2, T3, T4> Builder(Type<ValueTuple<T1, T2, T3, T4>> b) => default;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R CollectItem<R, C>(ref C colctor, int index, Type<ValueTuple<T1, T2, T3, T4>> b)
        where C : ITupleSeraColctor<ValueTuple<T1, T2, T3, T4>, R>
        => index switch
        {
            0 => colctor.CItem(d1, new ValueTupleEffector<T1, T2, T3, T4>.Item1(), new Type<T1>()),
            1 => colctor.CItem(d2, new ValueTupleEffector<T1, T2, T3, T4>.Item2(), new Type<T2>()),
            2 => colctor.CItem(d3, new ValueTupleEffector<T1, T2, T3, T4>.Item3(), new Type<T3>()),
            3 => colctor.CItem(d4, new ValueTupleEffector<T1, T2, T3, T4>.Item4(), new Type<T4>()),
            _ => colctor.CNone(),
        };
}

public static class ValueTupleEffector<T1, T2, T3, T4>
{
    public readonly struct Item1 : ISeraEffector<ValueTuple<T1, T2, T3, T4>, T1>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Effect(ref ValueTuple<T1, T2, T3, T4> target, T1 value)
            => target.Item1 = value;
    }
    public readonly struct Item2 : ISeraEffector<ValueTuple<T1, T2, T3, T4>, T2>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Effect(ref ValueTuple<T1, T2, T3, T4> target, T2 value)
            => target.Item2 = value;
    }
    public readonly struct Item3 : ISeraEffector<ValueTuple<T1, T2, T3, T4>, T3>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Effect(ref ValueTuple<T1, T2, T3, T4> target, T3 value)
            => target.Item3 = value;
    }
    public readonly struct Item4 : ISeraEffector<ValueTuple<T1, T2, T3, T4>, T4>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Effect(ref ValueTuple<T1, T2, T3, T4> target, T4 value)
            => target.Item4 = value;
    }
}

public readonly struct ValueTupleToTupleMapper<T1, T2, T3, T4> : 
    ISeraMapper<ValueTuple<T1, T2, T3, T4>, Tuple<T1, T2, T3, T4>>
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Tuple<T1, T2, T3, T4> Map(ValueTuple<T1, T2, T3, T4> value, InType<Tuple<T1, T2, T3, T4>>? u) 
        => new(value.Item1, value.Item2, value.Item3, value.Item4);
}

#endregion

#region Size5

public readonly struct TupleImpl<T1, T2, T3, T4, T5, D1, D2, D3, D4, D5>
    (D1 d1, D2 d2, D3 d3, D4 d4, D5 d5) :
    ISeraColion<ValueTuple<T1, T2, T3, T4, T5>>,
    ISeraColion<Tuple<T1, T2, T3, T4, T5>>,
    ITupleRestSeraColion<ValueTuple<T1, T2, T3, T4, T5>>,
    ITupleRestSeraColion<Tuple<T1, T2, T3, T4, T5>>,
    ITupleSeraColion<ValueTuple<T1, T2, T3, T4, T5>>
    where D1 : ISeraColion<T1>
    where D2 : ISeraColion<T2>
    where D3 : ISeraColion<T3>
    where D4 : ISeraColion<T4>
    where D5 : ISeraColion<T5>
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R Collect<R, C>(ref C colctor, InType<ValueTuple<T1, T2, T3, T4, T5>>? t) where C : ISeraColctor<ValueTuple<T1, T2, T3, T4, T5>, R>
        => colctor.CTuple(this, new IdentityMapper<ValueTuple<T1, T2, T3, T4, T5>>(), new Type<ValueTuple<T1, T2, T3, T4, T5>>());

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R Collect<R, C>(ref C colctor, InType<Tuple<T1, T2, T3, T4, T5>>? t) where C : ISeraColctor<Tuple<T1, T2, T3, T4, T5>, R>
        => colctor.CTuple(this, new ValueTupleToTupleMapper<T1, T2, T3, T4, T5>(), new Type<ValueTuple<T1, T2, T3, T4, T5>>());

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R CollectRest<R, C>(ref C colctor, InType<ValueTuple<T1, T2, T3, T4, T5>>? t = null) where C : ITupleRestSeraColctor<ValueTuple<T1, T2, T3, T4, T5>, R>
        => colctor.CTupleRest(this, new IdentityMapper<ValueTuple<T1, T2, T3, T4, T5>>(), new Type<ValueTuple<T1, T2, T3, T4, T5>>());

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R CollectRest<R, C>(ref C colctor, InType<Tuple<T1, T2, T3, T4, T5>>? t = null) where C : ITupleRestSeraColctor<Tuple<T1, T2, T3, T4, T5>, R>
        => colctor.CTupleRest(this, new ValueTupleToTupleMapper<T1, T2, T3, T4, T5>(), new Type<ValueTuple<T1, T2, T3, T4, T5>>());

    public int? Size
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => 5;
    }

    public int? TotalSize
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => 5;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public ValueTuple<T1, T2, T3, T4, T5> Builder(Type<ValueTuple<T1, T2, T3, T4, T5>> b) => default;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R CollectItem<R, C>(ref C colctor, int index, Type<ValueTuple<T1, T2, T3, T4, T5>> b)
        where C : ITupleSeraColctor<ValueTuple<T1, T2, T3, T4, T5>, R>
        => index switch
        {
            0 => colctor.CItem(d1, new ValueTupleEffector<T1, T2, T3, T4, T5>.Item1(), new Type<T1>()),
            1 => colctor.CItem(d2, new ValueTupleEffector<T1, T2, T3, T4, T5>.Item2(), new Type<T2>()),
            2 => colctor.CItem(d3, new ValueTupleEffector<T1, T2, T3, T4, T5>.Item3(), new Type<T3>()),
            3 => colctor.CItem(d4, new ValueTupleEffector<T1, T2, T3, T4, T5>.Item4(), new Type<T4>()),
            4 => colctor.CItem(d5, new ValueTupleEffector<T1, T2, T3, T4, T5>.Item5(), new Type<T5>()),
            _ => colctor.CNone(),
        };
}

public static class ValueTupleEffector<T1, T2, T3, T4, T5>
{
    public readonly struct Item1 : ISeraEffector<ValueTuple<T1, T2, T3, T4, T5>, T1>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Effect(ref ValueTuple<T1, T2, T3, T4, T5> target, T1 value)
            => target.Item1 = value;
    }
    public readonly struct Item2 : ISeraEffector<ValueTuple<T1, T2, T3, T4, T5>, T2>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Effect(ref ValueTuple<T1, T2, T3, T4, T5> target, T2 value)
            => target.Item2 = value;
    }
    public readonly struct Item3 : ISeraEffector<ValueTuple<T1, T2, T3, T4, T5>, T3>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Effect(ref ValueTuple<T1, T2, T3, T4, T5> target, T3 value)
            => target.Item3 = value;
    }
    public readonly struct Item4 : ISeraEffector<ValueTuple<T1, T2, T3, T4, T5>, T4>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Effect(ref ValueTuple<T1, T2, T3, T4, T5> target, T4 value)
            => target.Item4 = value;
    }
    public readonly struct Item5 : ISeraEffector<ValueTuple<T1, T2, T3, T4, T5>, T5>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Effect(ref ValueTuple<T1, T2, T3, T4, T5> target, T5 value)
            => target.Item5 = value;
    }
}

public readonly struct ValueTupleToTupleMapper<T1, T2, T3, T4, T5> : 
    ISeraMapper<ValueTuple<T1, T2, T3, T4, T5>, Tuple<T1, T2, T3, T4, T5>>
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Tuple<T1, T2, T3, T4, T5> Map(ValueTuple<T1, T2, T3, T4, T5> value, InType<Tuple<T1, T2, T3, T4, T5>>? u) 
        => new(value.Item1, value.Item2, value.Item3, value.Item4, value.Item5);
}

#endregion

#region Size6

public readonly struct TupleImpl<T1, T2, T3, T4, T5, T6, D1, D2, D3, D4, D5, D6>
    (D1 d1, D2 d2, D3 d3, D4 d4, D5 d5, D6 d6) :
    ISeraColion<ValueTuple<T1, T2, T3, T4, T5, T6>>,
    ISeraColion<Tuple<T1, T2, T3, T4, T5, T6>>,
    ITupleRestSeraColion<ValueTuple<T1, T2, T3, T4, T5, T6>>,
    ITupleRestSeraColion<Tuple<T1, T2, T3, T4, T5, T6>>,
    ITupleSeraColion<ValueTuple<T1, T2, T3, T4, T5, T6>>
    where D1 : ISeraColion<T1>
    where D2 : ISeraColion<T2>
    where D3 : ISeraColion<T3>
    where D4 : ISeraColion<T4>
    where D5 : ISeraColion<T5>
    where D6 : ISeraColion<T6>
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R Collect<R, C>(ref C colctor, InType<ValueTuple<T1, T2, T3, T4, T5, T6>>? t) where C : ISeraColctor<ValueTuple<T1, T2, T3, T4, T5, T6>, R>
        => colctor.CTuple(this, new IdentityMapper<ValueTuple<T1, T2, T3, T4, T5, T6>>(), new Type<ValueTuple<T1, T2, T3, T4, T5, T6>>());

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R Collect<R, C>(ref C colctor, InType<Tuple<T1, T2, T3, T4, T5, T6>>? t) where C : ISeraColctor<Tuple<T1, T2, T3, T4, T5, T6>, R>
        => colctor.CTuple(this, new ValueTupleToTupleMapper<T1, T2, T3, T4, T5, T6>(), new Type<ValueTuple<T1, T2, T3, T4, T5, T6>>());

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R CollectRest<R, C>(ref C colctor, InType<ValueTuple<T1, T2, T3, T4, T5, T6>>? t = null) where C : ITupleRestSeraColctor<ValueTuple<T1, T2, T3, T4, T5, T6>, R>
        => colctor.CTupleRest(this, new IdentityMapper<ValueTuple<T1, T2, T3, T4, T5, T6>>(), new Type<ValueTuple<T1, T2, T3, T4, T5, T6>>());

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R CollectRest<R, C>(ref C colctor, InType<Tuple<T1, T2, T3, T4, T5, T6>>? t = null) where C : ITupleRestSeraColctor<Tuple<T1, T2, T3, T4, T5, T6>, R>
        => colctor.CTupleRest(this, new ValueTupleToTupleMapper<T1, T2, T3, T4, T5, T6>(), new Type<ValueTuple<T1, T2, T3, T4, T5, T6>>());

    public int? Size
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => 6;
    }

    public int? TotalSize
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => 6;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public ValueTuple<T1, T2, T3, T4, T5, T6> Builder(Type<ValueTuple<T1, T2, T3, T4, T5, T6>> b) => default;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R CollectItem<R, C>(ref C colctor, int index, Type<ValueTuple<T1, T2, T3, T4, T5, T6>> b)
        where C : ITupleSeraColctor<ValueTuple<T1, T2, T3, T4, T5, T6>, R>
        => index switch
        {
            0 => colctor.CItem(d1, new ValueTupleEffector<T1, T2, T3, T4, T5, T6>.Item1(), new Type<T1>()),
            1 => colctor.CItem(d2, new ValueTupleEffector<T1, T2, T3, T4, T5, T6>.Item2(), new Type<T2>()),
            2 => colctor.CItem(d3, new ValueTupleEffector<T1, T2, T3, T4, T5, T6>.Item3(), new Type<T3>()),
            3 => colctor.CItem(d4, new ValueTupleEffector<T1, T2, T3, T4, T5, T6>.Item4(), new Type<T4>()),
            4 => colctor.CItem(d5, new ValueTupleEffector<T1, T2, T3, T4, T5, T6>.Item5(), new Type<T5>()),
            5 => colctor.CItem(d6, new ValueTupleEffector<T1, T2, T3, T4, T5, T6>.Item6(), new Type<T6>()),
            _ => colctor.CNone(),
        };
}

public static class ValueTupleEffector<T1, T2, T3, T4, T5, T6>
{
    public readonly struct Item1 : ISeraEffector<ValueTuple<T1, T2, T3, T4, T5, T6>, T1>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Effect(ref ValueTuple<T1, T2, T3, T4, T5, T6> target, T1 value)
            => target.Item1 = value;
    }
    public readonly struct Item2 : ISeraEffector<ValueTuple<T1, T2, T3, T4, T5, T6>, T2>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Effect(ref ValueTuple<T1, T2, T3, T4, T5, T6> target, T2 value)
            => target.Item2 = value;
    }
    public readonly struct Item3 : ISeraEffector<ValueTuple<T1, T2, T3, T4, T5, T6>, T3>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Effect(ref ValueTuple<T1, T2, T3, T4, T5, T6> target, T3 value)
            => target.Item3 = value;
    }
    public readonly struct Item4 : ISeraEffector<ValueTuple<T1, T2, T3, T4, T5, T6>, T4>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Effect(ref ValueTuple<T1, T2, T3, T4, T5, T6> target, T4 value)
            => target.Item4 = value;
    }
    public readonly struct Item5 : ISeraEffector<ValueTuple<T1, T2, T3, T4, T5, T6>, T5>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Effect(ref ValueTuple<T1, T2, T3, T4, T5, T6> target, T5 value)
            => target.Item5 = value;
    }
    public readonly struct Item6 : ISeraEffector<ValueTuple<T1, T2, T3, T4, T5, T6>, T6>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Effect(ref ValueTuple<T1, T2, T3, T4, T5, T6> target, T6 value)
            => target.Item6 = value;
    }
}

public readonly struct ValueTupleToTupleMapper<T1, T2, T3, T4, T5, T6> : 
    ISeraMapper<ValueTuple<T1, T2, T3, T4, T5, T6>, Tuple<T1, T2, T3, T4, T5, T6>>
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Tuple<T1, T2, T3, T4, T5, T6> Map(ValueTuple<T1, T2, T3, T4, T5, T6> value, InType<Tuple<T1, T2, T3, T4, T5, T6>>? u) 
        => new(value.Item1, value.Item2, value.Item3, value.Item4, value.Item5, value.Item6);
}

#endregion

#region Size7

public readonly struct TupleImpl<T1, T2, T3, T4, T5, T6, T7, D1, D2, D3, D4, D5, D6, D7>
    (D1 d1, D2 d2, D3 d3, D4 d4, D5 d5, D6 d6, D7 d7) :
    ISeraColion<ValueTuple<T1, T2, T3, T4, T5, T6, T7>>,
    ISeraColion<Tuple<T1, T2, T3, T4, T5, T6, T7>>,
    ITupleRestSeraColion<ValueTuple<T1, T2, T3, T4, T5, T6, T7>>,
    ITupleRestSeraColion<Tuple<T1, T2, T3, T4, T5, T6, T7>>,
    ITupleSeraColion<ValueTuple<T1, T2, T3, T4, T5, T6, T7>>
    where D1 : ISeraColion<T1>
    where D2 : ISeraColion<T2>
    where D3 : ISeraColion<T3>
    where D4 : ISeraColion<T4>
    where D5 : ISeraColion<T5>
    where D6 : ISeraColion<T6>
    where D7 : ISeraColion<T7>
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R Collect<R, C>(ref C colctor, InType<ValueTuple<T1, T2, T3, T4, T5, T6, T7>>? t) where C : ISeraColctor<ValueTuple<T1, T2, T3, T4, T5, T6, T7>, R>
        => colctor.CTuple(this, new IdentityMapper<ValueTuple<T1, T2, T3, T4, T5, T6, T7>>(), new Type<ValueTuple<T1, T2, T3, T4, T5, T6, T7>>());

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R Collect<R, C>(ref C colctor, InType<Tuple<T1, T2, T3, T4, T5, T6, T7>>? t) where C : ISeraColctor<Tuple<T1, T2, T3, T4, T5, T6, T7>, R>
        => colctor.CTuple(this, new ValueTupleToTupleMapper<T1, T2, T3, T4, T5, T6, T7>(), new Type<ValueTuple<T1, T2, T3, T4, T5, T6, T7>>());

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R CollectRest<R, C>(ref C colctor, InType<ValueTuple<T1, T2, T3, T4, T5, T6, T7>>? t = null) where C : ITupleRestSeraColctor<ValueTuple<T1, T2, T3, T4, T5, T6, T7>, R>
        => colctor.CTupleRest(this, new IdentityMapper<ValueTuple<T1, T2, T3, T4, T5, T6, T7>>(), new Type<ValueTuple<T1, T2, T3, T4, T5, T6, T7>>());

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R CollectRest<R, C>(ref C colctor, InType<Tuple<T1, T2, T3, T4, T5, T6, T7>>? t = null) where C : ITupleRestSeraColctor<Tuple<T1, T2, T3, T4, T5, T6, T7>, R>
        => colctor.CTupleRest(this, new ValueTupleToTupleMapper<T1, T2, T3, T4, T5, T6, T7>(), new Type<ValueTuple<T1, T2, T3, T4, T5, T6, T7>>());

    public int? Size
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => 7;
    }

    public int? TotalSize
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => 7;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public ValueTuple<T1, T2, T3, T4, T5, T6, T7> Builder(Type<ValueTuple<T1, T2, T3, T4, T5, T6, T7>> b) => default;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R CollectItem<R, C>(ref C colctor, int index, Type<ValueTuple<T1, T2, T3, T4, T5, T6, T7>> b)
        where C : ITupleSeraColctor<ValueTuple<T1, T2, T3, T4, T5, T6, T7>, R>
        => index switch
        {
            0 => colctor.CItem(d1, new ValueTupleEffector<T1, T2, T3, T4, T5, T6, T7>.Item1(), new Type<T1>()),
            1 => colctor.CItem(d2, new ValueTupleEffector<T1, T2, T3, T4, T5, T6, T7>.Item2(), new Type<T2>()),
            2 => colctor.CItem(d3, new ValueTupleEffector<T1, T2, T3, T4, T5, T6, T7>.Item3(), new Type<T3>()),
            3 => colctor.CItem(d4, new ValueTupleEffector<T1, T2, T3, T4, T5, T6, T7>.Item4(), new Type<T4>()),
            4 => colctor.CItem(d5, new ValueTupleEffector<T1, T2, T3, T4, T5, T6, T7>.Item5(), new Type<T5>()),
            5 => colctor.CItem(d6, new ValueTupleEffector<T1, T2, T3, T4, T5, T6, T7>.Item6(), new Type<T6>()),
            6 => colctor.CItem(d7, new ValueTupleEffector<T1, T2, T3, T4, T5, T6, T7>.Item7(), new Type<T7>()),
            _ => colctor.CNone(),
        };
}

public static class ValueTupleEffector<T1, T2, T3, T4, T5, T6, T7>
{
    public readonly struct Item1 : ISeraEffector<ValueTuple<T1, T2, T3, T4, T5, T6, T7>, T1>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Effect(ref ValueTuple<T1, T2, T3, T4, T5, T6, T7> target, T1 value)
            => target.Item1 = value;
    }
    public readonly struct Item2 : ISeraEffector<ValueTuple<T1, T2, T3, T4, T5, T6, T7>, T2>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Effect(ref ValueTuple<T1, T2, T3, T4, T5, T6, T7> target, T2 value)
            => target.Item2 = value;
    }
    public readonly struct Item3 : ISeraEffector<ValueTuple<T1, T2, T3, T4, T5, T6, T7>, T3>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Effect(ref ValueTuple<T1, T2, T3, T4, T5, T6, T7> target, T3 value)
            => target.Item3 = value;
    }
    public readonly struct Item4 : ISeraEffector<ValueTuple<T1, T2, T3, T4, T5, T6, T7>, T4>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Effect(ref ValueTuple<T1, T2, T3, T4, T5, T6, T7> target, T4 value)
            => target.Item4 = value;
    }
    public readonly struct Item5 : ISeraEffector<ValueTuple<T1, T2, T3, T4, T5, T6, T7>, T5>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Effect(ref ValueTuple<T1, T2, T3, T4, T5, T6, T7> target, T5 value)
            => target.Item5 = value;
    }
    public readonly struct Item6 : ISeraEffector<ValueTuple<T1, T2, T3, T4, T5, T6, T7>, T6>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Effect(ref ValueTuple<T1, T2, T3, T4, T5, T6, T7> target, T6 value)
            => target.Item6 = value;
    }
    public readonly struct Item7 : ISeraEffector<ValueTuple<T1, T2, T3, T4, T5, T6, T7>, T7>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Effect(ref ValueTuple<T1, T2, T3, T4, T5, T6, T7> target, T7 value)
            => target.Item7 = value;
    }
}

public readonly struct ValueTupleToTupleMapper<T1, T2, T3, T4, T5, T6, T7> : 
    ISeraMapper<ValueTuple<T1, T2, T3, T4, T5, T6, T7>, Tuple<T1, T2, T3, T4, T5, T6, T7>>
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Tuple<T1, T2, T3, T4, T5, T6, T7> Map(ValueTuple<T1, T2, T3, T4, T5, T6, T7> value, InType<Tuple<T1, T2, T3, T4, T5, T6, T7>>? u) 
        => new(value.Item1, value.Item2, value.Item3, value.Item4, value.Item5, value.Item6, value.Item7);
}

#endregion

#region Size >= 8

public readonly struct TupleRestValueImpl<
        T1, T2, T3, T4, T5, T6, T7, TR,
        D1, D2, D3, D4, D5, D6, D7, DR
    >
    (D1 d1, D2 d2, D3 d3, D4 d4, D5 d5, D6 d6, D7 d7, DR dr, int size) :
    ISeraColion<ValueTuple<T1, T2, T3, T4, T5, T6, T7, TR>>,
    ITupleRestSeraColion<ValueTuple<T1, T2, T3, T4, T5, T6, T7, TR>>,
    ITupleSeraColion<ValueTuple<T1, T2, T3, T4, T5, T6, T7, TR>>
    where D1 : ISeraColion<T1>
    where D2 : ISeraColion<T2>
    where D3 : ISeraColion<T3>
    where D4 : ISeraColion<T4>
    where D5 : ISeraColion<T5>
    where D6 : ISeraColion<T6>
    where D7 : ISeraColion<T7>
    where TR : struct
    where DR : ITupleRestSeraColion<TR>
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R Collect<R, C>(ref C colctor, InType<ValueTuple<T1, T2, T3, T4, T5, T6, T7, TR>>? t) where C : ISeraColctor<ValueTuple<T1, T2, T3, T4, T5, T6, T7, TR>, R>
        => colctor.CTuple(this, new IdentityMapper<ValueTuple<T1, T2, T3, T4, T5, T6, T7, TR>>(), new Type<ValueTuple<T1, T2, T3, T4, T5, T6, T7, TR>>());

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R CollectRest<R, C>(ref C colctor, InType<ValueTuple<T1, T2, T3, T4, T5, T6, T7, TR>>? t) where C : ITupleRestSeraColctor<ValueTuple<T1, T2, T3, T4, T5, T6, T7, TR>, R>
        => colctor.CTupleRest(this, new IdentityMapper<ValueTuple<T1, T2, T3, T4, T5, T6, T7, TR>>(), new Type<ValueTuple<T1, T2, T3, T4, T5, T6, T7, TR>>());

    public int? Size
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => 8;
    }

    public int? TotalSize
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => size;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public ValueTuple<T1, T2, T3, T4, T5, T6, T7, TR> Builder(Type<ValueTuple<T1, T2, T3, T4, T5, T6, T7, TR>> b) => default;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R CollectItem<R, C>(ref C colctor, int index, Type<ValueTuple<T1, T2, T3, T4, T5, T6, T7, TR>> b)
        where C : ITupleSeraColctor<ValueTuple<T1, T2, T3, T4, T5, T6, T7, TR>, R>
        => index switch
        {
            0 => colctor.CItem(d1, new ValueTupleEffector<T1, T2, T3, T4, T5, T6, T7, TR>.Item1(), new Type<T1>()),
            1 => colctor.CItem(d2, new ValueTupleEffector<T1, T2, T3, T4, T5, T6, T7, TR>.Item2(), new Type<T2>()),
            2 => colctor.CItem(d3, new ValueTupleEffector<T1, T2, T3, T4, T5, T6, T7, TR>.Item3(), new Type<T3>()),
            3 => colctor.CItem(d4, new ValueTupleEffector<T1, T2, T3, T4, T5, T6, T7, TR>.Item4(), new Type<T4>()),
            4 => colctor.CItem(d5, new ValueTupleEffector<T1, T2, T3, T4, T5, T6, T7, TR>.Item5(), new Type<T5>()),
            5 => colctor.CItem(d6, new ValueTupleEffector<T1, T2, T3, T4, T5, T6, T7, TR>.Item6(), new Type<T6>()),
            6 => colctor.CItem(d7, new ValueTupleEffector<T1, T2, T3, T4, T5, T6, T7, TR>.Item7(), new Type<T7>()),
            >= 7 => colctor.CRest(dr, index - 7, new ValueTupleEffector<T1, T2, T3, T4, T5, T6, T7, TR>.Rest(), new Type<TR>()),
            _ => colctor.CNone(),
        };
}

public readonly struct TupleRestClassImpl<
        T1, T2, T3, T4, T5, T6, T7, TR,
        D1, D2, D3, D4, D5, D6, D7, DR
    >
    (D1 d1, D2 d2, D3 d3, D4 d4, D5 d5, D6 d6, D7 d7, DR dr, int size) :
    ISeraColion<Tuple<T1, T2, T3, T4, T5, T6, T7, TR>>,
    ITupleRestSeraColion<Tuple<T1, T2, T3, T4, T5, T6, T7, TR>>,
    ITupleSeraColion<(T1, T2, T3, T4, T5, T6, T7, TR)>
    where D1 : ISeraColion<T1>
    where D2 : ISeraColion<T2>
    where D3 : ISeraColion<T3>
    where D4 : ISeraColion<T4>
    where D5 : ISeraColion<T5>
    where D6 : ISeraColion<T6>
    where D7 : ISeraColion<T7>
    where TR : class
    where DR : ITupleRestSeraColion<TR>
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R Collect<R, C>(ref C colctor, InType<Tuple<T1, T2, T3, T4, T5, T6, T7, TR>>? t) where C : ISeraColctor<Tuple<T1, T2, T3, T4, T5, T6, T7, TR>, R>
        => colctor.CTuple(this, new ValueTuple8ToTupleMapper<T1, T2, T3, T4, T5, T6, T7, TR>(), new Type<(T1, T2, T3, T4, T5, T6, T7, TR)>());

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R CollectRest<R, C>(ref C colctor, InType<Tuple<T1, T2, T3, T4, T5, T6, T7, TR>>? t) where C : ITupleRestSeraColctor<Tuple<T1, T2, T3, T4, T5, T6, T7, TR>, R>
        => colctor.CTupleRest(this, new ValueTuple8ToTupleMapper<T1, T2, T3, T4, T5, T6, T7, TR>(), new Type<(T1, T2, T3, T4, T5, T6, T7, TR)>());

    public int? Size
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => 8;
    }

    public int? TotalSize
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => size;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public (T1, T2, T3, T4, T5, T6, T7, TR) Builder(Type<(T1, T2, T3, T4, T5, T6, T7, TR)> b) => default;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R CollectItem<R, C>(ref C colctor, int index, Type<(T1, T2, T3, T4, T5, T6, T7, TR)> b)
        where C : ITupleSeraColctor<(T1, T2, T3, T4, T5, T6, T7, TR), R>
        => index switch
        {
            0 => colctor.CItem(d1, new ValueTuple8Effector<T1, T2, T3, T4, T5, T6, T7, TR>.Item1(), new Type<T1>()),
            1 => colctor.CItem(d2, new ValueTuple8Effector<T1, T2, T3, T4, T5, T6, T7, TR>.Item2(), new Type<T2>()),
            2 => colctor.CItem(d3, new ValueTuple8Effector<T1, T2, T3, T4, T5, T6, T7, TR>.Item3(), new Type<T3>()),
            3 => colctor.CItem(d4, new ValueTuple8Effector<T1, T2, T3, T4, T5, T6, T7, TR>.Item4(), new Type<T4>()),
            4 => colctor.CItem(d5, new ValueTuple8Effector<T1, T2, T3, T4, T5, T6, T7, TR>.Item5(), new Type<T5>()),
            5 => colctor.CItem(d6, new ValueTuple8Effector<T1, T2, T3, T4, T5, T6, T7, TR>.Item6(), new Type<T6>()),
            6 => colctor.CItem(d7, new ValueTuple8Effector<T1, T2, T3, T4, T5, T6, T7, TR>.Item7(), new Type<T7>()),
            >= 7 => colctor.CRest(dr, index - 7, new ValueTuple8Effector<T1, T2, T3, T4, T5, T6, T7, TR>.Item8(), new Type<TR>()),
            _ => colctor.CNone(),
        };
}

public static class ValueTupleEffector<T1, T2, T3, T4, T5, T6, T7, TR>
    where TR : struct
{
    public readonly struct Item1 : ISeraEffector<ValueTuple<T1, T2, T3, T4, T5, T6, T7, TR>, T1>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Effect(ref ValueTuple<T1, T2, T3, T4, T5, T6, T7, TR> target, T1 value)
            => target.Item1 = value;
    }
    public readonly struct Item2 : ISeraEffector<ValueTuple<T1, T2, T3, T4, T5, T6, T7, TR>, T2>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Effect(ref ValueTuple<T1, T2, T3, T4, T5, T6, T7, TR> target, T2 value)
            => target.Item2 = value;
    }
    public readonly struct Item3 : ISeraEffector<ValueTuple<T1, T2, T3, T4, T5, T6, T7, TR>, T3>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Effect(ref ValueTuple<T1, T2, T3, T4, T5, T6, T7, TR> target, T3 value)
            => target.Item3 = value;
    }
    public readonly struct Item4 : ISeraEffector<ValueTuple<T1, T2, T3, T4, T5, T6, T7, TR>, T4>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Effect(ref ValueTuple<T1, T2, T3, T4, T5, T6, T7, TR> target, T4 value)
            => target.Item4 = value;
    }
    public readonly struct Item5 : ISeraEffector<ValueTuple<T1, T2, T3, T4, T5, T6, T7, TR>, T5>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Effect(ref ValueTuple<T1, T2, T3, T4, T5, T6, T7, TR> target, T5 value)
            => target.Item5 = value;
    }
    public readonly struct Item6 : ISeraEffector<ValueTuple<T1, T2, T3, T4, T5, T6, T7, TR>, T6>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Effect(ref ValueTuple<T1, T2, T3, T4, T5, T6, T7, TR> target, T6 value)
            => target.Item6 = value;
    }
    public readonly struct Item7 : ISeraEffector<ValueTuple<T1, T2, T3, T4, T5, T6, T7, TR>, T7>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Effect(ref ValueTuple<T1, T2, T3, T4, T5, T6, T7, TR> target, T7 value)
            => target.Item7 = value;
    }
    public readonly struct Rest : ISeraEffector<ValueTuple<T1, T2, T3, T4, T5, T6, T7, TR>, TR>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Effect(ref ValueTuple<T1, T2, T3, T4, T5, T6, T7, TR> target, TR value)
            => target.Rest = value;
    }
}

public static class ValueTuple8Effector<T1, T2, T3, T4, T5, T6, T7, T8>
{
    public readonly struct Item1 : ISeraEffector<(T1, T2, T3, T4, T5, T6, T7, T8), T1>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Effect(ref (T1, T2, T3, T4, T5, T6, T7, T8) target, T1 value)
            => target.Item1 = value;
    }
    public readonly struct Item2 : ISeraEffector<(T1, T2, T3, T4, T5, T6, T7, T8), T2>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Effect(ref (T1, T2, T3, T4, T5, T6, T7, T8) target, T2 value)
            => target.Item2 = value;
    }
    public readonly struct Item3 : ISeraEffector<(T1, T2, T3, T4, T5, T6, T7, T8), T3>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Effect(ref (T1, T2, T3, T4, T5, T6, T7, T8) target, T3 value)
            => target.Item3 = value;
    }
    public readonly struct Item4 : ISeraEffector<(T1, T2, T3, T4, T5, T6, T7, T8), T4>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Effect(ref (T1, T2, T3, T4, T5, T6, T7, T8) target, T4 value)
            => target.Item4 = value;
    }
    public readonly struct Item5 : ISeraEffector<(T1, T2, T3, T4, T5, T6, T7, T8), T5>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Effect(ref (T1, T2, T3, T4, T5, T6, T7, T8) target, T5 value)
            => target.Item5 = value;
    }
    public readonly struct Item6 : ISeraEffector<(T1, T2, T3, T4, T5, T6, T7, T8), T6>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Effect(ref (T1, T2, T3, T4, T5, T6, T7, T8) target, T6 value)
            => target.Item6 = value;
    }
    public readonly struct Item7 : ISeraEffector<(T1, T2, T3, T4, T5, T6, T7, T8), T7>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Effect(ref (T1, T2, T3, T4, T5, T6, T7, T8) target, T7 value)
            => target.Item7 = value;
    }
    public readonly struct Item8 : ISeraEffector<(T1, T2, T3, T4, T5, T6, T7, T8), T8>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Effect(ref (T1, T2, T3, T4, T5, T6, T7, T8) target, T8 value)
            => target.Item8 = value;
    }
}

public readonly struct ValueTuple8ToTupleMapper<T1, T2, T3, T4, T5, T6, T7, TR> : 
    ISeraMapper<(T1, T2, T3, T4, T5, T6, T7, TR), Tuple<T1, T2, T3, T4, T5, T6, T7, TR>>
    where TR : class
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Tuple<T1, T2, T3, T4, T5, T6, T7, TR> Map((T1, T2, T3, T4, T5, T6, T7, TR) value, InType<Tuple<T1, T2, T3, T4, T5, T6, T7, TR>>? u) 
        => new(value.Item1, value.Item2, value.Item3, value.Item4, value.Item5, value.Item6, value.Item7, value.Item8);
}

#endregion
