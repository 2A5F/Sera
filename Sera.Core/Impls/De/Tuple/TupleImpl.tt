<#@ template language="C#" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// <auto-generated>

#nullable enable

using System;
using System.Runtime.CompilerServices;
using Sera.Core.Impls.De;
using Sera.Utils;

namespace Sera.Core.Impls.De;

<#
    string BuildGenerics(string name, int len)
    {
        var sb = new StringBuilder();
        var first = true;
        for (var i = 1; i <= len; i++)
        {
            if (first) first = false;
            else sb.Append(", ");
            sb.Append($"{name}{i}");
        }
        return sb.ToString();
    }

    string BuildParams(string type, string name, int len)
    {
        var sb = new StringBuilder();
        var first = true;
        for (var i = 1; i <= len; i++)
        {
            if (first) first = false;
            else sb.Append(", ");
            sb.Append($"{type}{i} {name}{i}");
        }
        return sb.ToString();
    }

    string BuildDWheres(int len)
    {
        var sb = new StringBuilder();
        var first = true;
        for (int i = 1; i <= len; i++)
        {
            if (first) first = false;
            else sb.Append("\n");
            sb.Append($"    where D{i} : ISeraColion<T{i}>");
        }
        return sb.ToString();
    }

    string BuildGetters(int len)
    {
        var sb = new StringBuilder();
        var first = true;
        for (int i = 1; i <= len; i++)
        {
            if (first) first = false;
            else sb.Append(", ");
            sb.Append($"value.Item{i}");
        }
        return sb.ToString();
    }
#>
#region Empty

public readonly struct TupleImpl : ISeraColion<ValueTuple>, ITupleSeraColion<ValueTuple>
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R Collect<R, C>(ref C colctor, InType<ValueTuple>? t = null) where C : ISeraColctor<ValueTuple, R>
        => colctor.CTuple(this, new IdentityMapper<ValueTuple>(), new Type<ValueTuple>());

    public int? Size
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => 0;
    }

    public int? TotalSize
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => 0;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public ValueTuple Builder(Type<ValueTuple> b = default) => default;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R CollectItem<R, C>(ref C colctor, int index, Type<ValueTuple> b = default)
        where C : ITupleSeraColctor<ValueTuple, R>
        => colctor.CNone();
}

#endregion
<#
    for (var i = 1; i <= 7; i++)
    {
        var gts = BuildGenerics("T", i);
        var gds = BuildGenerics("D", i);
        var pds = BuildParams("D", "d", i);
        var wheres = BuildDWheres(i);
        var getters = BuildGetters(i);
#>

#region Size<#= i #>

public readonly struct TupleImpl<<#= gts #>, <#= gds #>>
    (<#= pds #>) :
    ISeraColion<ValueTuple<<#= gts #>>>,
    ISeraColion<Tuple<<#= gts #>>>,
    ITupleRestSeraColion<ValueTuple<<#= gts #>>>,
    ITupleRestSeraColion<Tuple<<#= gts #>>>,
    ITupleSeraColion<ValueTuple<<#= gts #>>>
<#= wheres #>
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R Collect<R, C>(ref C colctor, InType<ValueTuple<<#= gts #>>>? t) where C : ISeraColctor<ValueTuple<<#= gts #>>, R>
        => colctor.CTuple(this, new IdentityMapper<ValueTuple<<#= gts #>>>(), new Type<ValueTuple<<#= gts #>>>());

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R Collect<R, C>(ref C colctor, InType<Tuple<<#= gts #>>>? t) where C : ISeraColctor<Tuple<<#= gts #>>, R>
        => colctor.CTuple(this, new ValueTupleToTupleMapper<<#= gts #>>(), new Type<ValueTuple<<#= gts #>>>());

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R CollectRest<R, C>(ref C colctor, InType<ValueTuple<<#= gts #>>>? t = null) where C : ITupleRestSeraColctor<ValueTuple<<#= gts #>>, R>
        => colctor.CTupleRest(this, new IdentityMapper<ValueTuple<<#= gts #>>>(), new Type<ValueTuple<<#= gts #>>>());

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R CollectRest<R, C>(ref C colctor, InType<Tuple<<#= gts #>>>? t = null) where C : ITupleRestSeraColctor<Tuple<<#= gts #>>, R>
        => colctor.CTupleRest(this, new ValueTupleToTupleMapper<<#= gts #>>(), new Type<ValueTuple<<#= gts #>>>());

    public int? Size
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => <#= i #>;
    }

    public int? TotalSize
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => <#= i #>;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public ValueTuple<<#= gts #>> Builder(Type<ValueTuple<<#= gts #>>> b) => default;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R CollectItem<R, C>(ref C colctor, int index, Type<ValueTuple<<#= gts #>>> b)
        where C : ITupleSeraColctor<ValueTuple<<#= gts #>>, R>
        => index switch
        {
<#
        for (var j = 0; j < i; j++)
        {
            var k = j + 1;
#>
            <#= j #> => colctor.CItem(d<#= k #>, new ValueTupleEffector<<#= gts #>>.Item<#= k #>(), new Type<T<#= k #>>()),
<#
        }
#>
            _ => colctor.CNone(),
        };
}

public static class ValueTupleEffector<<#= gts #>>
{
<#
        for (var j = 1; j <= i; j++)
        {
#>
    public readonly struct Item<#= j #> : ISeraEffector<ValueTuple<<#= gts #>>, T<#= j #>>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Effect(ref ValueTuple<<#= gts #>> target, T<#= j #> value)
            => target.Item<#= j #> = value;
    }
<#
        }
#>
}

public readonly struct ValueTupleToTupleMapper<<#= gts #>> : 
    ISeraMapper<ValueTuple<<#= gts #>>, Tuple<<#= gts #>>>
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Tuple<<#= gts #>> Map(ValueTuple<<#= gts #>> value, InType<Tuple<<#= gts #>>>? u) 
        => new(<#= getters #>);
}

#endregion
<#
    }
#>

<#
    {
        var gts = BuildGenerics("T", 7);
        var gds = BuildGenerics("D", 7);
        var pds = BuildParams("D", "d", 7);
        var wheres = BuildDWheres(7);
        var getters = BuildGetters(7);
#>
#region Size >= 8

public readonly struct TupleRestValueImpl<
        <#= gts #>, TR,
        <#= gds #>, DR
    >
    (<#= pds #>, DR dr, int size) :
    ISeraColion<ValueTuple<<#= gts #>, TR>>,
    ITupleRestSeraColion<ValueTuple<<#= gts #>, TR>>,
    ITupleSeraColion<ValueTuple<<#= gts #>, TR>>
<#= wheres #>
    where TR : struct
    where DR : ITupleRestSeraColion<TR>
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R Collect<R, C>(ref C colctor, InType<ValueTuple<<#= gts #>, TR>>? t) where C : ISeraColctor<ValueTuple<<#= gts #>, TR>, R>
        => colctor.CTuple(this, new IdentityMapper<ValueTuple<<#= gts #>, TR>>(), new Type<ValueTuple<<#= gts #>, TR>>());

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R CollectRest<R, C>(ref C colctor, InType<ValueTuple<<#= gts #>, TR>>? t) where C : ITupleRestSeraColctor<ValueTuple<<#= gts #>, TR>, R>
        => colctor.CTupleRest(this, new IdentityMapper<ValueTuple<<#= gts #>, TR>>(), new Type<ValueTuple<<#= gts #>, TR>>());

    public int? Size
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => 8;
    }

    public int? TotalSize
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => size;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public ValueTuple<<#= gts #>, TR> Builder(Type<ValueTuple<<#= gts #>, TR>> b) => default;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R CollectItem<R, C>(ref C colctor, int index, Type<ValueTuple<<#= gts #>, TR>> b)
        where C : ITupleSeraColctor<ValueTuple<<#= gts #>, TR>, R>
        => index switch
        {
<#
        for (var j = 0; j < 7; j++)
        {
            var k = j + 1;
#>
            <#= j #> => colctor.CItem(d<#= k #>, new ValueTupleEffector<<#= gts #>, TR>.Item<#= k #>(), new Type<T<#= k #>>()),
<#
        }
#>
            >= 7 => colctor.CRest(dr, index - 7, new ValueTupleEffector<<#= gts #>, TR>.Rest(), new Type<TR>()),
            _ => colctor.CNone(),
        };
}

public readonly struct TupleRestClassImpl<
        <#= gts #>, TR,
        <#= gds #>, DR
    >
    (<#= pds #>, DR dr, int size) :
    ISeraColion<Tuple<<#= gts #>, TR>>,
    ITupleRestSeraColion<Tuple<<#= gts #>, TR>>,
    ITupleSeraColion<(<#= gts #>, TR)>
<#= wheres #>
    where TR : class
    where DR : ITupleRestSeraColion<TR>
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R Collect<R, C>(ref C colctor, InType<Tuple<<#= gts #>, TR>>? t) where C : ISeraColctor<Tuple<<#= gts #>, TR>, R>
        => colctor.CTuple(this, new ValueTuple8ToTupleMapper<<#= gts #>, TR>(), new Type<(<#= gts #>, TR)>());

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R CollectRest<R, C>(ref C colctor, InType<Tuple<<#= gts #>, TR>>? t) where C : ITupleRestSeraColctor<Tuple<<#= gts #>, TR>, R>
        => colctor.CTupleRest(this, new ValueTuple8ToTupleMapper<<#= gts #>, TR>(), new Type<(<#= gts #>, TR)>());

    public int? Size
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => 8;
    }

    public int? TotalSize
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => size;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public (<#= gts #>, TR) Builder(Type<(<#= gts #>, TR)> b) => default;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public R CollectItem<R, C>(ref C colctor, int index, Type<(<#= gts #>, TR)> b)
        where C : ITupleSeraColctor<(<#= gts #>, TR), R>
        => index switch
        {
<#
        for (var j = 0; j < 7; j++)
        {
            var k = j + 1;
#>
            <#= j #> => colctor.CItem(d<#= k #>, new ValueTuple8Effector<<#= gts #>, TR>.Item<#= k #>(), new Type<T<#= k #>>()),
<#
        }
#>
            >= 7 => colctor.CRest(dr, index - 7, new ValueTuple8Effector<<#= gts #>, TR>.Item8(), new Type<TR>()),
            _ => colctor.CNone(),
        };
}

public static class ValueTupleEffector<<#= gts #>, TR>
    where TR : struct
{
<#
        for (var j = 1; j <= 7; j++)
        {
#>
    public readonly struct Item<#= j #> : ISeraEffector<ValueTuple<<#= gts #>, TR>, T<#= j #>>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Effect(ref ValueTuple<<#= gts #>, TR> target, T<#= j #> value)
            => target.Item<#= j #> = value;
    }
<#
        }
#>
    public readonly struct Rest : ISeraEffector<ValueTuple<<#= gts #>, TR>, TR>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Effect(ref ValueTuple<<#= gts #>, TR> target, TR value)
            => target.Rest = value;
    }
}

public static class ValueTuple8Effector<<#= gts #>, T8>
{
<#
        for (var j = 1; j <= 8; j++)
        {
#>
    public readonly struct Item<#= j #> : ISeraEffector<(<#= gts #>, T8), T<#= j #>>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Effect(ref (<#= gts #>, T8) target, T<#= j #> value)
            => target.Item<#= j #> = value;
    }
<#
        }
#>
}

public readonly struct ValueTuple8ToTupleMapper<<#= gts #>, TR> : 
    ISeraMapper<(<#= gts #>, TR), Tuple<<#= gts #>, TR>>
    where TR : class
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Tuple<<#= gts #>, TR> Map((<#= gts #>, TR) value, InType<Tuple<<#= gts #>, TR>>? u) 
        => new(<#= getters #>, value.Item8);
}

#endregion
<#
    }
#>
